Threads

Поток - это ход выполнения программы. Процесс - это несколько потоков (Как минимум один).
Потоки живут в одном процессе; используют общую память Heap и другие ресурсы (взаимодействие - измененине одного объекта разными потоками). При старте приложения создается поток Main
Потоки могут порождать другие потоки, взаимодействовать с ними.

Thread инкапсулирует поток. Thread - это объект, у которого есть методы start() и run().
После вызова метода start() в очередь к ресурсам будет поставлен и когда-либо будет вызван метод run(), все в run() будет выполняться в новом потоке.

Object.wait() -ждать в текущем потоке, пока не придет notify()
object.notify() - сигнал продолжить одному из потоков, которые  wait()
object.notifyAll() - сигнал продолжить всем, кто начал wait()

Критическая секция - участок кода, к которой должен быть доступ только у одного потока. Например, запись в файл

Семафор - объект, ограничивающий кол-во поток, которые могут в него войти.
Содержит счетчик, методы enter() - ждет, пока счетчик станет больше нуля, и уменьшить на единицу; и leave() - увеличить счетчик на единицу

Mutex (Mutual excusion) - двоичный семафор, счетчик либо 0, либо 1

Блокировка - механизм синхронизации, обеспечивающий доступ к общему для нескольких потоков ресурсу. Реализован аппаратно.

Монитор - состоит из Mutex и массива ожидающих потоков. Если метод synchronized - сам объект класса будет монитором.
Если использовать блок synchronized c аргументом объектом lock, то этот объект будет монитором (если, например, в одном методе разные потоки могут менять разные переменные)

Ошибки одновременного доступа:
- потеря результата (из-за неатомарности операции)
- неверное состояние общей памяти

Java Memory model
Описывает взаимодействие потоков через общую память
Инструменты:
final - не изменять значение переменной
volatile - не кешировать значение, всегда читать из общей памяти
synchronized - участок кода доступен только одному потоку

библиотека concurrent использует метод compareAndSwap(), основанный на "железе", без использования synchronized
java.Util.HashTable - synchronized
ConcurrentHashMap - разрешено одновременное чтение и безопасная запись

CopyOnWriteArrayList, CopyOnWriteArraySet - хороши для частого чтения и редкой вставки. При вставке нового элемента создается новая копия, а другой поток работает со старой копией.
ConcurrentHashMap
ConcurrentSkipListSet, Map - ключи уникальны и отсортированы
ConcurrentLinkedQueue -
BlockingQueue - очередь с ограничением размера (если размер достигнут, потоки ждут)
BlockingDeque -


*****
Очередь обработки запросов. Каждый сервис (model, view, controller) - выполняется в своем потоке. Для каждого сервиса есть очередь запросов к нему
Один поток кладет в коллекцию сообщение; другой поток достает сообщение и исполняет его

Варианты взаимодейтсвия потоков:
- в одни поток ссылку на другой;
- общий объект
- события/обработчики

***
Message System
- одна система сообщений на процесс
- единственный объект, доступный из нескольких потоков (каждый сервис - в своем потоке)
- по одной очереди сообщений на поток
- каждый поток берет свою очередь и выполняет сообщения
- у каждого потока свой адрес
- из любого места потока можно положить сообщение в очередь по адресу (ответ на сообщение)




