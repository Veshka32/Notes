Архитектура субд: ядро, диспетчер данных, диспетчер запросов, инструменты для служебных операций
MySql - свободная, для вебсайтов.

Архитектура ANSI SPARC определяет принципы организации СУБД:
- пользователи должны быть абстрагированы от физ. и лог. организации данных;
- у разных ролей - разные представления данных;
- администраторы могут вносить изменения в схему данных без учета физ. хранения данных в системе;
- внутренняя структура бд не зависит от физических аспектов хранения данных.

Уровни: внешний (представления), концептуальный (логическая структура), внутренний (физическая реализация). Логическая и физическая независимость.

-------------------

*** Проектирование БД ***
Решаются задачи: отображение объектов, их связей, формирование ограничений целостности.
Отображение предметной области в виде отношений (реляционная модель) не всегда удобно и понятно, иногда и невозможно.

Концептуальная схема - > логическая схема в терминах реляционной модели - > физическая модель.
Модель сущность-связь (ER)

Концептульная схема
- сущность (реальный объект), тип сущности. Сущности должны быть отличимы.
- связь, тип связи. Связи должны быть бинарны. Один к одному, многие к одному, многие ко многим, один к одному. Кратность - одному объекту от 0 до n, или от 1 до n. Один к одному - человек/паспорт. Можно объединить в одну сущность.
- атрибут, тип данных
- ключи
- ограничения целостности
Проверка - наличие связей 1 к 1, избыточные связи, выполнимость операций.

Логическая схема
- тип отображается в отношение
- атрибуты -> атрибуты отношений
- идентификаторы -> в первичный ключ
- связи 1 к 1, 1 ко многим -> внешние ключи
- многие ко мнигм -> доп. отношения
- сложные связи - >декомпозиция с введением новых типов сущностей.
- многозначные атрибуты ->  декомпозиция с введением новых типов сущностей
- супертипы и подтипы: одна либо  несколько таблиц
- вазимоисключающие связи: общее/раздельное хранение внешних ключей

Физическое проектирование (перенос логической схемы в конкретную СУБД)
- определение типов данных и допустимых значений для атрибутов, допустимость неопр. значений;
- стратегия обработки исключительных ситуаций;
- названия;
- реализация ограничений целостности;
- хранение, вычисление производных атрибутов;
- формирование индексов;
- секционирование и партицирование;
Пропускная способность, время ответа, утилизируемые ресурсы

Справочник - сущность, упрощающая изменение домена какого-то атрибута (добавление новых возможных значений)

*** Структура реляционных БД ***
операторы языка SQL:
- DDL - data definition language (Create alter drop)
- DML - data manipulating;
- DCL - data control (grant reboke) - права доступа

Типы данных:
INT - 4 байта
FLOAT, DOUBLE 4 байта приближенные
DECIMAL для операций сравнения
СHAR фиксированная длина (добавит пробелы)
VARCHAR переменная длина (хранится еще и длина) 
DATE,TIME,TIMESTAMP
xml, JSON

Объекты БД:
- таблицы. Имена полей уникальны, в одном поле один тип данных, значение в ячейке атомарно, порядок строк и столбцов несущественнен
- правила целостности: not null, unique, check, primary key, foreign key;
- индексы;
- представления, или правила выборки данных;
- функции: блок операторов на SQL в контексте конкретной субд;
- триггеры: функция, к-рая вызывается автоматически при наступлении события.

*Таблицы*
Домен - одз атрибута. Столбец - аттрибут. Строка - кортеж. Схема отношений - заголовок таблицы; тело - строки; значение отношения- заголовок плюс строки.

*Правила целостности*
Целостность сущности:
- кортежи (строки) должны отличаться хоть чем-то; минимальный набор аттрибутов, по к-рым можно отличить - потенциальный ключ. Ключ не может содержать неопределенных значений.

*Ссылочная целостность:*
- для каждого внешнего ключа должен найтись кортеж в отношении, на которое ссылается вн.ключ. Способы поддержания: блокировка операции, указания ключа как null,каскадное удаление.
селекция (ограничения) - выбор нескольких строк по условию;
проекция - выбор нескольких столбцов;
соединение по условию - join
деление - A:B=c - такое с, что BxC=A;

Primary key: not null, unique,one column; таблица может быть без первичного ключа;
Foreign key: when the primary key appears in diff table;
Объединение обычно по primary key одной таблицы и этому же foreign key в другой.

foreign key задаются при создании таблицы для связывания с другой, тогда же можно задать каскадные правила целосности (что делать при изменении-удалении родительской таблицы)

*Представления*
Представление (именованные запросы, виртуальная таблица на основе запроса, всегда up-to-date)
CREATE VIEW view_name AS SELECT col_name, col_name2 FROM table_name WHERE col_name2=cond WITH CHECK OPTION; //определение представления, с проверкой;
SELECT col_name, col_name2 FROM view_name WHERE col_name=val;//обращение к представлению

*Процедуры и функции*
Процедуры (именованная программа, к-рая хранится как объект базы. Состоит из операторов DDL)
Исполняются сервером БД, т.е. наиболее близко к месту хранения данных. Могут изменять данные и стуктуру бд, могут возвращать данные как select.
CALL procedureName(arg); DROP PROCEDURE procName;
Функция, в отличие от процедуры, возвращает результат; не могут изменять значения в таблицах. Содержит return. SELECT funcname(...);

*Триггеры*
Процедура (без параметров), выполняемая при события в базе данных. Инициирующие события: INSERT,UPDTE,DELETE, изменение схемы. Может выполняться до или после события, для каждой строки или для блока. Триггер создается для одной конкретной таблицы. 
Транзакционность, возможность использовать старые и новые значения, исполняются последовательно (если на одно событие несколько триггеров) по времени создания.
Используются для: проверка данных, поддержка согласованности, аудит.
Недостатки: непрозрачность, производительность, сложность отладки.
CREATE TRIGGER trigger_name {BEFORE|AFTER} {INSERT|UPDATE|DELETE} ON table_name FOR EACH ROW trigger_body


***Индексы***
Индекс организован как сбалансированное дерево, каждый уровень - блоки с диапазонами значений ключа.

Кластерный индекс - главый. Если указать primary key, то индекс строится по нему; если не указать, то по первому unique полю. Иначе - суррогатное поле. Можно неск полей. Можно выбрать поле для построение кластерного индекса.
Кластерный индекс хранит реальные строки данных в "листьях", значения отсортированы, поэтому у каждой  таблицы только 1 кластерный индекс.

Если данных очень мало, частые вставки и мало запросов - то лучше без кластера (куча).

Некластерный индекс - строится после кластерного. Автоматически для полей unique или командой Create Index. В "листьях" хранятся только ключевые столбцы и указатели на строки с реальными данными в таблице (на кластерный ключ). Можно включить и неключевые поля. Некластерные индексы не отсортированы, можно создать до 999 индексов.

Индекс В-дерево - для поиска, сортировки, сравнения; хэш-индекс - внешний ключ, where in()

CREATE {UNIQUE|FULLTEXT|SPATIAL} INDEX index_name ON table_name(col_name);
Индекс можно определить по нескольким столбцам; порядок важен!
ОБновление таблиц с индексами делается дольше, чем без, поэтому индексы только для полей, по которым будет частый поиск.

Полнотекстовый индекс: только один для таблицы, включает один или несколько столбцов. Текст разбивается на слова, определяются стоп-слова (которые есть везде и не помогают в поиске), инверия (у каждого слова - в каком оно документе).
Поиск выполняется командой MATCH
SELECT * FROM table WHERE MATCH (col_name) AGAINST ("value") - вернет строки с выражением value и степень релевантности.

Составной индекс
Содержит более 1 столбца, не более 16, общая длина не более 900 байт.

Покрывающий индекс (когда в листьях некластерного индекса хранятся не только ключевые, но и доп. поля, которые часто в запросе вместе с ключевыми).

Можно создать фильтруемый индекс.

Индексы обновляются автоматически при обновлении строки с даными. Для часто обновляемых таблиц - как можно меньше индексов. Для кластеризованных индексов- использовать поля как можно короче. Чем больше дубликатов в столбце, тем хуже работает индекс. Для составного индекса первым использовать поле, к-рое используется в WHERE

Индексы на основе битовых карт
Подходят для таблиц, где в каждом столбце ограниченное кол-во значений.
Для каждого столбца - одно из значений и  битовая строка, в которой каждый бит 1 - если значение в строке соотв. этому параметру.
красный 010
Синий 100
зеленый 001 Сумма 111

Для нахождения по неск. параметрам - битовое умножение; позиции индекса - номера искомых строк.

Пространственный индекс
CREATE TABLE geom(g GEOMETRY);
CREATE SPATIAL INDEX sp_index ON geom (g);

*** Нормализация ***
Наилучшая группировка атрибутов, чтобы избежать избыточности и аномалий. При этом могут создаваться новые отношения, удаляться или переноситься атрибуты.
Полная функциональная зависимость атрибутов: зависимый атрибут зависит от полного значения детерминанта и не зависит от подмножеств значений.

1я нормальная форма - атрибут не является списком-кортежем (в ячейке только одно значение). Чтобы привести к этой форме, можно декомпозировать список в ячейке, либо сделать доп.таблицу (многие ко многим).

2я нормальная форма: 1 нф+каждый атрибут, не входящий в первичный ключ, полностью зависит от ключа в целом. Если первичный ключ из одного атрибута, то это уже 2 нф. Вынести атрибут, к-рый не полностью зависит от ключа,в новое отношение.

3я нормальная форма: 2нф+ нет транзитивно зависимых атрибутов.
Нормальная форма Бойса-Кодда: 3 нф+все детерминанты должны быть потенциальными ключами. Если нет, выделить их в отдельное отношение. Можно убрать лишние ключи, чтоб остался только один потенциальный ключ.
4я нф: бойс-кодд+многозначная зависимость или одна (Функциональная), или нет.

***Планы***
План - описание, какие отношения, операции и в какой последовательности будут использованы для выполнения запроса. 
на выполнение запроса влияет конфигурация памяти, сервер, ОС, внутренний оптимизатор субд (входит в субд), конструкция запросов.

Стратегия MySQL:
- начинает с таблицы, где меньше кортежей;
- более жесткие условия первые;
- какие ключи использовать, чтобы больше отсеять.

EXPLAIN SELECT * FROM table WHERE col1=val AND col2=VAL2; // просмотр плана: кол-во кортежей, индексы, порядок операций.

Оптимизатор "улучшает" запрос, строит возможные планы, выбирает оптимальный: можно подряд по всем строкам, можно по индексу col1 или col2. Собирается статистическая инфа(кол-во блоков в таблице,записей, средняя длина записи, наличие индексов  и тд).

Правила для запросов:
- индексы не будут использованы: where col>col2; where col is not null; where col like, where col!= expression
- если функция с индексированным столбцом идет после where, то индекс не используется;
- для фильтрации записи использовать where а не having(чтобы использовать индексы)
- если индекс по двум столбцам, то в where обязательно указать первый столбец
- при выборе более 15% строк быстрее полный просмотр, а не индекс?
- вместо select union select - select where in()
- чтобы уменьшить кол-во вложенных запросов, делать промежуточные выборки
- если в основной выборке много строк, а в подзапросе мало - IN
- если в основной выборке мало строк, а подзапрос сложный - EXISTS
- если оба запроса сложные - JOIN
- в оперативной памяти хранятся планы запросов - используйте одинаковые запросы

Предоставление прав
GRANT {что} ON {на что} TO {кому}
GRANT {что} TO {кому} WITHADMIN OPTION
GRANT SELECT ON table TO username WITH GRANT OPTION 
Отмена прав - REVOKE
роли - CREATE ROLE

***Транзакции***
Транзакция - неделимая группа операций, из одного согласованного состояния базы - в другое. Атомарны, изолированы,согласованы, прочны.
Менеджер транзакций гарантирут согласованность бд. Диспетчер транзакций.
Неявные транзакции (по умолчанию) - каждая отдельная команда.
Явные транзакции:
start transaction, commit, rollbak
START TRANSACTION;
INSERT INTO table(col) VALUES (val);
UPDATE table SET(col,val);
SELECT * FROM table;
COMMIT;

Проблемы
- потерянные обновления (два пользвателя обновляют одновременно)
- грязные данные (транзакция rollback)
- неповторяющееся чтения. пока один считывает, другой изменяет

Уровень изоляции транзакции 
SET TRANSACTION IZOLATION LEVEL
-read uncommitted; готова считывать промежуточные данные
- read committed; читает только закомиченные данные
- repetable read по умолчанию. Блокирует считанный диапазондля других транзакций. Но при этом могут вставить новые строки в этот диапазон
- serializable. Нельзя даже добавлять данные в прочитанный диапазон
- snapshot: на момент начала транзакции фиксируется состояние базы, при коммите проверяется, не менялись ли данные, которые менял пользователь, если да, то действие обрывается.

*** NoSQL (not only sql) БД *** 
для хранения опр. вида данных. Для распределенных БД. Нереляционные модели.
Разделение для хранения по столбцам, а не по строкам.
BASE-архитектура: сбой узла приводит к отказу только части системы. Система может находится в неустойчивом состоянии, но рано или поздно она вернется в согласованное состояние.
Map-reduce - разделить, предобработать и объединить (для больших данных). Инструмент Hadoop. Работвет даже при отказе одного из узлов, может давать неточные ответы.

СУБД  по хэшу: Redis, Memcached. ДЛя работы с данными в реальном времени (чаты, игры), файловые системы, кэширование результатов долгих операций.
СУБД документные: MongoDB, Amazon. хранят JSON, bitJSON
СУБД колоночные:Cassandra (данные с веб-страниц, большие объемы данных)
СУБД графоориентированные

Объектно-реляционное отображение (OR Mapping).
Связывает ООП и реляционные модели. ORM - это интерфейс (модель) (работает с java-объектами, формирует sql-запросы). Hibernate - ORM-фреймворк.
- ORM не зависит от СУБД;
- упрощает моделирование БД;
- доп. механизмы целосности данных (напр., ограничения домена);
- использование наследования моделей;


https://www.w3schools.com/sql/default.asp
Structure query language

USE database;
CREATE TABLE table_name(name INTEGER PRIMARY KEY, name1 TEXT NOT NULL, name2 TEXT DEFAULT "text", name3 TEXT UNIQUE); имя столбца, тип данных обязательны;

DESCRIBE table;
ALTER TABLE table_name MODIFY COLUMN col_name DATA_TYPE(ARG); - изменить тип данных
ALTER TABLE table_name DROP COLUMN col_name;
DELETE FROM table_name WHERE ... ; удаление по одной строке
TRUNCATE table_name; - удалить все строки;
DROP TABLE table_name; - удалить всю таблицу

INSERT INTO table_name (column_name, column_name1) VALUES (val1,val2);

UPDATE table_name SET column_name=value WHERE column_name1=value1;

ALTER TABLE table_name ADD COLUMN column_name TYPE; //add column

DELETE FROM celebs WHERE twitter_handle IS NULL;

SELECT column_name FROM table_name;
SELECT col_name, col_name2 FROM table_name;
SELECT col_name AS name_for_resultSet FROM table_name;
SELECT DISTINCT col_name FROM table_name;
SELECT * FROM table_name WHERE col_name>expression AND col_name=value;
SELECT * FROM table_name WHERE col_name>expression OR col_name=value;
SELECT * FROM table_name WHERE col_name LIKE "A_A%"; "-" wildcard for one symbol, % - several
SELECT * FROM table_name WHERE col_name IS NOT NULL;
SELECT * FROM table_name WHERE col_name BETWEEN val AND val; (for int - inclusive, for letters - not)
SELECT col_name FROM table_name ORDER BY name DESC;
SELECT * FROM table_name ORDER BY col_name DESC LIMIT 3; 

SELECT name,
 CASE
  WHEN col_name=value THEN value;
  WHEN col_name=value THEN value;
  ELSE value
 END AS temp_col_name
FROM table_name; //if else analog

SELECT COUNT(*) FROM table_name WHERE name=0; //количество
MAX(), MIN(), AVG()

SELECT ROUND(AVG(col_name),2) FROM table_name;
SELECT col_name, COUNT(*) FROM table_name GROUP BY col_name
// GROUP after WHERE and before ORDER, LIMIT

SELECT name, SUM(name2) FROM table_name GROUP BY name;

SELECT category,price, AVG(downloads) FROM fake_apps GROUP BY 1,2 ORDER BY 2 DESC; // номера колонок; группировка по двум сразу

SELECT price, ROUND(AVG(downloads)), COUNT(*) FROM fake_apps GROUP BY price HAVING COUNT(downloads)>0; //кол-во загрузок>0 для каждой ценовой категории

SELECT category, COUNT(*) FROM startups GROUP BY category
HAVING COUNT(*) > 3; //кол-во компаний для каждой категории, где компаний больше 3;

select location, avg(employees) from startups group by location having avg(employees)>500;

/*Joining tables*/
SELECT * FROM table1 JOIN table2 ON table1.column_id=table2.column_id //выбрать все колонки из объединенной таблицы по условию. inner join - попадают только те строки, по которым есть полное совпадение объединяющих колонок; 

SELECT * FROM table1 LEFT JOIN table2 ON table1.c2 = table2.c2; //left join - сохранит все строки левой таблицы при объединении;

SELECT * FROM table1 LEFT JOIN table2 ON table1.nme=table2.name WHERE table2.name IS NULL; // left/right outer join

SELECT table.colname, table2.colname2 FROM table  CROSS JOIN table2; //все возможные сочетания строк

NATURAL JOIN

select month, count(*) as "Subs" from newspaper cross join months where start_month<=month and end_month>=month group by month;

/*union tables*/
SELECT * FROM table UNION SELECT * FROM table2; //одинаковое число столбцов и одинаковые типы данных в том же порядке

/*temporary table*/
WITH  temp_name AS( --- QUERY---) SELECT table.name FROM temp_name JOIN table2 ON temp_name.col=table2.col;

/*rAnking*/
SELECT p.*, COUNT(*) AS sale_count, RANK() OVER (ORDER BY COUNT(*) DESC) AS sale_rank
FROM people p JOIN sales s ON p.id = s.people_id
GROUP BY p.id

/*IN*/
SELECT id, name FROM departments WHERE id IN (SELECT department_id FROM sales WHERE price > 98);
